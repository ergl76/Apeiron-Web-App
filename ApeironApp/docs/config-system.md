# üìã Config-System Dokumentation

## √úbersicht

Das Apeiron Web App verwendet ein **config-basiertes System** f√ºr flexible Spielbalance und Inhalte. Alle Spielparameter sind in JSON-Dateien ausgelagert und werden zur Build-Time importiert.

**Vorteile:**
- ‚úÖ Einfache Balance-Anpassungen ohne Code-√Ñnderungen
- ‚úÖ Neue Events/Tiles ohne Logik-√Ñnderungen hinzuf√ºgbar
- ‚úÖ Klare Trennung zwischen Daten und Logik
- ‚úÖ √úbersichtliche Wartung durch zentrale Config-Dateien

---

## 1Ô∏è‚É£ events.json

### Ladezeitpunkt
```javascript
// ApeironGame.jsx:2
import eventsConfig from './config/events.json';
```

**Import-Typ:** Build-Time Import (statisch)

### Verwendung im Code

#### Initial Deck-Erstellung
```javascript
// ApeironGame.jsx:945
eventDeck: [...eventsConfig.phase1.positive, ...eventsConfig.phase1.negative]
```
- **Zeitpunkt:** Bei Spielinitialisierung (useState)
- **Scope:** Event Deck wird EINMAL erstellt beim neuen Spiel

#### Event-Effekt Anwendung
```javascript
// ApeironGame.jsx:2071-2073
const newAp = Math.max(0, player.ap - effect.value);
console.log(`‚ö° reduce_ap ONE-TIME: ${player.name} AP reduced to ${newAp}`);
return { ...player, ap: newAp };
```
- **Zeitpunkt:** W√§hrend des Spiels bei Event-Trigger
- **Quelle:** `effect.value` kommt direkt aus Event-Objekt im Deck

#### Event-Text Generierung
```javascript
// ApeironGame.jsx:2082
resolvedTexts.push(`Schwere B√ºrde: ${playerNames} haben ${durationText} -${effect.value} AP.`);
```

### Wann werden √Ñnderungen wirksam?

| Szenario | Wirksam nach | Bestehendes Spiel betroffen? |
|----------|--------------|----------------------------|
| **Development** | Browser-Refresh (HMR) | ‚ùå Nein - Deck bereits erstellt |
| **Production** | Neues Build + Deploy | ‚ùå Nein - Deck bereits erstellt |
| **Neues Spiel** | Spielstart | ‚úÖ Ja - Neues Deck wird erstellt |

**‚ö†Ô∏è Wichtig:** Event-Deck wird beim Spielstart erstellt. √Ñnderungen betreffen nur **neue Spiele**, nicht laufende Sessions.

---

## 2Ô∏è‚É£ gameRules.json

### Ladezeitpunkt
```javascript
// ApeironGame.jsx:4
import gameRules from './config/gameRules.json';
```

**Import-Typ:** Build-Time Import (statisch)

### Verwendung im Code (15+ Stellen)

#### Initial-Werte (Bei Spielstart)
```javascript
// ApeironGame.jsx:888
light: gameRules.light.startValue  // Initial Light: 30

// ApeironGame.jsx:894-895
ap: gameRules.actionPoints.perTurn,      // AP pro Runde: 3
maxAp: gameRules.actionPoints.maxPerTurn, // Max AP: 5

// ApeironGame.jsx:897
maxInventory: gameRules.inventory.maxSlots  // Inventar-Slots: 2
```

#### Runtime-Checks (Jede Runde)
```javascript
// ApeironGame.jsx:1440
if (lightLoss >= gameRules.light.torDerWeisheitTrigger && !gameState.torDerWeisheit.triggered) {
  // Tor der Weisheit bei 8 Light Verlust (= 22 Light remaining)
}

// ApeironGame.jsx:1964
newState.light = Math.min(gameRules.light.maxValue, newState.light + gainValue);
// Max Light: 50

// ApeironGame.jsx:6536
width: `${(gameState.light / gameRules.light.maxValue) * 100}%`
// Light-Bar Prozent-Berechnung
```

#### Foundation System
```javascript
// ApeironGame.jsx:2628
const foundationBonus = gameRules.foundations.lightBonusPerFoundation; // +4 Light

// ApeironGame.jsx:2639
light: Math.max(0, Math.min(gameRules.light.maxValue, prev.light + totalBonus))
```

#### Element-Aktivierung
```javascript
// ApeironGame.jsx:2843
const bonusConfig = gameRules.elementActivation.bonuses[element];
// z.B. wasser: {type: "light", value: 4, darknessReduction: 4}

// Light Bonus anwenden
if (bonusConfig.type === 'light') {
  newState.light = Math.min(
    gameRules.light.maxValue,
    newState.light + bonusConfig.value
  );
}

// AP Bonus anwenden
if (bonusConfig.type === 'permanent_ap') {
  newState.players = newState.players.map(player => ({
    ...player,
    maxAp: player.maxAp + bonusConfig.value
  }));
}

// Finsternis-Zur√ºckdr√§ngung (seit 2025-10-06)
const darknessReduction = bonusConfig.darknessReduction || 0;
if (darknessReduction > 0 && newState.herzDerFinsternis.darkTiles.length > 0) {
  const fieldsToRemove = Math.min(
    darknessReduction,
    newState.herzDerFinsternis.darkTiles.length
  );
  newState.herzDerFinsternis.darkTiles =
    newState.herzDerFinsternis.darkTiles.slice(0, -fieldsToRemove);
}
```

### Wann werden √Ñnderungen wirksam?

| Typ | Beispiel | Wirksam nach | Bestehendes Spiel? |
|-----|----------|--------------|-------------------|
| **Initial-Werte** | `light.startValue` | Browser-Refresh | ‚ùå Nein (State bereits initialisiert) |
| **Runtime-Checks** | `light.maxValue` | Browser-Refresh | ‚úÖ Ja (wird bei jedem Check neu gelesen) |
| **Trigger-Werte** | `torDerWeisheitTrigger` | Browser-Refresh | ‚úÖ Ja (Check passiert jede Runde) |
| **Bonus-Werte** | `lightBonusPerFoundation` | Browser-Refresh | ‚úÖ Ja (beim n√§chsten Foundation-Build) |

**‚úÖ Dynamisch:** Viele gameRules-Werte werden zur **Runtime** abgefragt und wirken sofort nach Refresh.

**‚ùå Statisch:** Initial-Werte (startValue, perTurn) nur bei **Spielstart** wirksam.

---

## 3Ô∏è‚É£ tiles.json

### Ladezeitpunkt
```javascript
// ApeironGame.jsx:3
import tilesConfig from './config/tiles.json';
```

**Import-Typ:** Build-Time Import (statisch)

### Verwendung im Code

#### Phase 1 Deck-Erstellung (Bei Spielstart)
```javascript
// ApeironGame.jsx:868-887
const phase1TileDeck = Object.entries(tilesConfig.phase1).flatMap(([tileId, config]) => {
  // Erstellt Array mit count-Wiederholungen
  // z.B. "fluss": {count: 5} ‚Üí 5√ó fluss im Deck
  return Array(config.count).fill(null).map(() => ({
    ...config,
    id: tileId
  }));
});

// ApeironGame.jsx:947
tileDeck: completeDeck.sort(() => Math.random() - 0.5)
```
- **Zeitpunkt:** Bei Spielinitialisierung
- **Shuffle:** Deck wird einmal gemischt

#### Phase 2 Deck-Erstellung (Bei Phase-√úbergang)
```javascript
// ApeironGame.jsx:2691-2715
const phase2TileDeck = Object.entries(tilesConfig.phase2).flatMap(
  ([tileId, config]) =>
    Array(config.count).fill(null).map(() => ({
      ...config,
      id: tileId
    }))
);
```
- **Zeitpunkt:** Beim √úbergang von Phase 1 ‚Üí Phase 2 (4 Fundamente gebaut)
- **Trigger:** User best√§tigt Phase Transition Modal

### Tile-Eigenschaften Verwendung
```javascript
// getTileResources() - Ressourcen auf Feld
config.resources?.forEach(r => { /* ... */ });

// getTileName() - Feld-Name
return config.name || 'Unbekannt';

// getTileSymbol() - Feld-Symbol
return config.symbol || '‚ùì';

// getTileColor() - Feld-Farbe
return config.color || '#6b7280';
```

### Wann werden √Ñnderungen wirksam?

| Deck | Erstellung | Wirksam nach | Bestehendes Spiel? |
|------|-----------|--------------|-------------------|
| **Phase 1** | Spielstart | Browser-Refresh | ‚ùå Nein (Deck bereits erstellt) |
| **Phase 2** | Phase-√úbergang | Browser-Refresh | ‚úÖ Ja (wenn Phase-Wechsel NACH Refresh) |

**‚ö†Ô∏è Wichtig:**
- Phase 1 Deck wird bei **Spielstart** erstellt ‚Üí Nur neue Spiele betroffen
- Phase 2 Deck wird bei **Phase-√úbergang** erstellt ‚Üí Betroffen wenn √úbergang nach Config-√Ñnderung

---

## üìä Vergleichstabelle: Alle Config-Dateien

| Config-Datei | Ladezeitpunkt | √Ñnderung wirksam nach | Bestehendes Spiel betroffen? | Dynamische Runtime-Checks? |
|--------------|---------------|----------------------|----------------------------|---------------------------|
| **events.json** | App-Start (Build-Time) | Browser-Refresh / Build | ‚ùå Nein (Deck bereits erstellt) | ‚ùå Nein |
| **gameRules.json** | App-Start (Build-Time) | Browser-Refresh / Build | ‚ö†Ô∏è Teilweise (Runtime ja, Initial nein) | ‚úÖ Ja (viele Checks) |
| **gameRules.phase2** | App-Start (Build-Time) | Browser-Refresh | ‚úÖ **Ja** (Runtime-Abfrage) | ‚úÖ Ja (bei jedem Spielerzug) |
| **tiles.json** | App-Start (Build-Time) | Browser-Refresh / Build | ‚ö†Ô∏è Phase 2 Deck ja, Phase 1 nein | ‚ùå Nein |

---

## 4Ô∏è‚É£ Phase 2 Configuration

### Ladezeitpunkt
```javascript
// ApeironGame.jsx:1959
const darknessSpreadCount = gameRules.phase2?.darknessSpreadPerTurn || 1;
```

**Import-Typ:** Build-Time Import (statisch), Runtime-Abfrage (dynamisch)

### Verwendung im Code

#### Automatische Finsternis-Ausbreitung (Zeile ~1959-1987)
```javascript
// ApeironGame.jsx:1959
const darknessSpreadCount = gameRules.phase2?.darknessSpreadPerTurn || 1;
const darknessSpreads = [];

if (shouldSpreadDarkness) {
  let tempState = { ...prevState };

  for (let i = 0; i < darknessSpreadCount; i++) {
    const nextPos = calculateNextDarknessPosition(tempState);

    if (nextPos) {
      darknessSpreads.push(nextPos);
      tempState = {
        ...tempState,
        herzDerFinsternis: {
          ...tempState.herzDerFinsternis,
          darkTiles: [...tempState.herzDerFinsternis.darkTiles, nextPos]
        }
      };
    } else {
      break; // No more valid positions
    }
  }
}
```

### Config-Parameter

| Parameter | Beschreibung | Default | Beispielwerte |
|-----------|--------------|---------|---------------|
| `darknessSpreadPerTurn` | Anzahl der Felder die pro Spielerzug von Finsternis befallen werden | `1` | `1` (leicht), `2` (normal), `3` (schwer) |

### Schwierigkeitsgrade

```json
// gameRules.json - Leichter Modus (Empfohlen f√ºr Einsteiger)
{
  "phase2": {
    "darknessSpreadPerTurn": 1
  }
}

// gameRules.json - Normaler Modus
{
  "phase2": {
    "darknessSpreadPerTurn": 2
  }
}

// gameRules.json - Schwerer Modus (F√ºr Experten)
{
  "phase2": {
    "darknessSpreadPerTurn": 3
  }
}
```

### Wann werden √Ñnderungen wirksam?

| √Ñnderung | Wirksam nach | Bestehendes Spiel betroffen? |
|----------|--------------|----------------------------|
| `darknessSpreadPerTurn` | Browser-Refresh | ‚úÖ Ja - wird bei jedem Spielerzug neu abgefragt |

**‚úÖ Dynamisch:** Der Wert wird zur **Runtime** bei jedem Spielerzug-Ende abgefragt.

**Impact:**
- Wert wird bei jedem `handleAutoTurnTransition` Call neu gelesen
- √Ñnderungen wirken **sofort** nach Browser-Refresh
- Bestehendes Spiel √ºbernimmt neue Geschwindigkeit

### Testing-Beispiel

#### Szenario: Finsternis-Ausbreitung von 1 ‚Üí 2 √§ndern

**1. Config √§ndern:**
```json
// src/config/gameRules.json
{
  "phase2": {
    "darknessSpreadPerTurn": 2  // ‚Üê GE√ÑNDERT von 1
  }
}
```

**2. Browser refresht** automatisch (HMR)

**3. Im bestehenden Spiel:**
- Phase 2 bereits aktiv? ‚úÖ Neue Geschwindigkeit gilt sofort!
- Spielerzug beenden ‚Üí Console-Log: `‚ò†Ô∏è darkness spreads to 4,5 (1/2)` + `‚ò†Ô∏è darkness spreads to 4,6 (2/2)`

**4. Validierung:**
- ‚úÖ Console zeigt 2√ó spread statt 1√ó
- ‚úÖ Board hat 2 neue dunkle Felder (statt 1)
- ‚úÖ Spiral-Algorithmus funktioniert korrekt f√ºr mehrere Felder

### Event-basierte Finsternis vs. Automatische Ausbreitung

**Wichtig:** `darknessSpreadPerTurn` gilt nur f√ºr **automatische Ausbreitung nach jedem Spielerzug**.

**Event-basierte Ausbreitung** (`spread_darkness` Events) verwenden **eigene** `value`-Parameter:

```json
// events.json - Event-basierte Ausbreitung
{
  "id": "welle_der_finsternis",
  "effects": [
    {
      "type": "spread_darkness",
      "value": 2  // ‚Üê Event-spezifischer Wert (unabh√§ngig von darknessSpreadPerTurn)
    }
  ]
}
```

**Unterschied:**
- **Automatisch** (jeder Spielerzug): `gameRules.phase2.darknessSpreadPerTurn`
- **Event-basiert** (nur bei Event): `effect.value` aus events.json

**Kombiniert:** Wenn Event mit `spread_darkness: 2` getriggert wird UND Spielerzug endet ‚Üí Insgesamt 2 (Event) + 1 (Auto) = **3 Felder** werden dunkel!

---

## 5Ô∏è‚É£ Element-Aktivierung Bonusse (darknessReduction)

### √úbersicht

Das **Element-Aktivierung System** (Phase 2) bietet konfigurierbare Boni wenn Spieler Elemente aktivieren. Seit Session 2025-10-06 gibt es zus√§tzlich das **Finsternis-Zur√ºckdr√§ngung Feature** (`darknessReduction`).

### Ladezeitpunkt
```javascript
// ApeironGame.jsx:4
import gameRules from './config/gameRules.json';
```

**Import-Typ:** Build-Time Import (statisch), Runtime-Abfrage (dynamisch)

### Config-Struktur

```json
{
  "elementActivation": {
    "bonuses": {
      "wasser": {
        "type": "light",           // Art des Bonus (light/permanent_ap)
        "value": 4,                // Bonus-Wert
        "darknessReduction": 4     // üÜï Anzahl Finsternis-Felder zur√ºckdr√§ngen
      },
      "feuer": {
        "type": "light",
        "value": 4,
        "darknessReduction": 4
      },
      "luft": {
        "type": "permanent_ap",
        "value": 1,
        "darknessReduction": 4
      },
      "erde": {
        "type": "permanent_ap",
        "value": 1,
        "darknessReduction": 4
      }
    }
  }
}
```

### Verwendung im Code

#### Element-Aktivierung Handler (Zeile ~2843-2900)

```javascript
// ApeironGame.jsx:2843
const bonusConfig = gameRules.elementActivation.bonuses[element];

// Haupt-Bonus anwenden (Light oder AP)
if (bonusConfig.type === 'light') {
  newState.light = Math.min(
    gameRules.light.maxValue,
    newState.light + bonusConfig.value
  );
}

// üÜï Finsternis-Zur√ºckdr√§ngung (LIFO-Prinzip)
const darknessReduction = bonusConfig.darknessReduction || 0;
let fieldsRemoved = 0;

if (darknessReduction > 0 && newState.herzDerFinsternis.darkTiles.length > 0) {
  const currentDarkCount = newState.herzDerFinsternis.darkTiles.length;
  const fieldsToRemove = Math.min(darknessReduction, currentDarkCount);

  // LIFO: Entfernt zuletzt erfasste Finsternis-Felder zuerst
  newState.herzDerFinsternis.darkTiles =
    newState.herzDerFinsternis.darkTiles.slice(0, -fieldsToRemove);

  fieldsRemoved = fieldsToRemove;

  console.log(
    `üåü ${element.toUpperCase()}-Element aktiviert: ` +
    `${fieldsRemoved} Finsternis-Felder zur√ºckgedr√§ngt! ` +
    `(${currentDarkCount} ‚Üí ${newState.herzDerFinsternis.darkTiles.length})`
  );
}
```

### LIFO-Prinzip (Last-In-First-Out)

**Warum LIFO?**
- Finsternis breitet sich **spiral-f√∂rmig** vom Herz aus
- Neueste Finsternis-Felder sind am **weitesten** vom Herz entfernt
- Zur√ºckdr√§ngung sollte **√§u√üeren Ring** zuerst entfernen (nicht Zentrum)

**Implementierung:**
```javascript
// Array: [√§lteste, ..., neueste]
// .slice(0, -N) entfernt N Elemente vom ENDE
darkTiles.slice(0, -2)  // Entfernt 2 neueste Felder
```

**Beispiel:**
```javascript
// Vor Aktivierung (5 dunkle Felder):
darkTiles = ['4,5', '5,5', '4,6', '5,6', '6,6']
           // Ring 1  Ring 1  Ring 2  Ring 2  Ring 2

// Element-Aktivierung mit darknessReduction: 2
darkTiles = ['4,5', '5,5', '4,6']  // ‚Üê '5,6' und '6,6' entfernt
           // Ring 1  Ring 1  Ring 2
```

### UI-Integration (Element Success Modal)

```javascript
// ApeironGame.jsx:~5950-5970
{fieldsRemoved > 0 && (
  <div className="border-t border-yellow-300/30 pt-3 mt-3">
    <div className="text-yellow-300 font-semibold text-base">
      ‚òÄÔ∏è {fieldsRemoved} Finsternis-Feld{fieldsRemoved > 1 ? 'er' : ''}
      zur√ºckgedr√§ngt!
    </div>
    <div className="text-yellow-100 text-sm mt-1">
      Die Macht des Elements vertreibt die Dunkelheit.
    </div>
  </div>
)}
```

**Design:**
- Separator-Line mit Border-Top
- Goldener Text (#fbbf24) matching Element-Farbe
- Dynamische Pluralisierung ("Feld" vs "Felder")
- Conditional Rendering (nur wenn `fieldsRemoved > 0`)

### Wann werden √Ñnderungen wirksam?

| √Ñnderung | Wirksam nach | Bestehendes Spiel betroffen? |
|----------|--------------|----------------------------|
| `value` (Light/AP Bonus) | Browser-Refresh | ‚úÖ Ja - Runtime-Abfrage bei Aktivierung |
| `darknessReduction` | Browser-Refresh | ‚úÖ Ja - Runtime-Abfrage bei Aktivierung |
| `type` (light/permanent_ap) | Browser-Refresh | ‚úÖ Ja - Runtime-Check |

**‚úÖ Dynamisch:** Alle Element-Aktivierung Werte werden zur **Runtime** abgefragt.

**Impact:**
- √Ñnderungen wirken **sofort** nach Browser-Refresh
- Bestehendes Spiel √ºbernimmt neue Werte bei n√§chster Element-Aktivierung
- Keine Notwendigkeit f√ºr neues Spiel

### Balance-Konfiguration

#### Standard-Werte (Aktuell)
```json
{
  "wasser": {"darknessReduction": 4},  // Wasser heilt am meisten
  "feuer": {"darknessReduction": 4},   // Feuer verbrennt Finsternis
  "luft": {"darknessReduction": 4},    // Luft vertreibt Schatten
  "erde": {"darknessReduction": 4}     // Erde festigt Licht
}
```

#### Schwierigkeitsgrade-Beispiele

**Leichter Modus** (mehr Finsternis-Zur√ºckdr√§ngung):
```json
{
  "wasser": {"darknessReduction": 5},
  "feuer": {"darknessReduction": 6},
  "luft": {"darknessReduction": 4},
  "erde": {"darknessReduction": 3}
}
```

**Normaler Modus** (ausgewogen):
```json
{
  "wasser": {"darknessReduction": 4},
  "feuer": {"darknessReduction": 4},
  "luft": {"darknessReduction": 4},
  "erde": {"darknessReduction": 4}
}
```

**Schwerer Modus** (weniger Zur√ºckdr√§ngung):
```json
{
  "wasser": {"darknessReduction": 2},
  "feuer": {"darknessReduction": 3},
  "luft": {"darknessReduction": 1},
  "erde": {"darknessReduction": 0}  // Erde gibt keinen Finsternis-Schutz
}
```

### Kombination mit automatischer Ausbreitung

**Wichtig:** Finsternis-Zur√ºckdr√§ngung passiert **VOR** automatischer Ausbreitung!

**Szenario:** Spieler aktiviert Feuer-Element (`darknessReduction: 3`)

1. **Element-Aktivierung:** 3 Finsternis-Felder entfernt (LIFO)
2. **AP verbraucht ‚Üí Spielerzug endet**
3. **Automatische Ausbreitung:** `darknessSpreadPerTurn` Felder werden dunkel

**Beispiel:**
```javascript
// Vor Element-Aktivierung: 10 dunkle Felder
// Nach Element-Aktivierung: 7 dunkle Felder (-3)
// Nach Turn-Transition: 9 dunkle Felder (+2 von darknessSpreadPerTurn)

// Netto-Effekt: -1 Feld (3 entfernt, 2 hinzugef√ºgt)
```

### Testing-Beispiel

#### Szenario: Feuer-Element darknessReduction von 4 ‚Üí 6 √§ndern

**1. Config √§ndern:**
```json
// src/config/gameRules.json
{
  "elementActivation": {
    "bonuses": {
      "feuer": {
        "type": "light",
        "value": 4,
        "darknessReduction": 6  // ‚Üê GE√ÑNDERT von 4
      }
    }
  }
}
```

**2. Browser refresht** automatisch (HMR)

**3. Im bestehenden Spiel:**
- Phase 2 aktiv mit 10 dunklen Feldern
- Spieler aktiviert Feuer-Element (1 AP + Kristall + Fragment)

**4. Validierung:**
- ‚úÖ Console: `üåü FEUER-Element aktiviert: 6 Finsternis-Felder zur√ºckgedr√§ngt! (10 ‚Üí 4)`
- ‚úÖ Element Success Modal zeigt: "‚òÄÔ∏è 6 Finsternis-Felder zur√ºckgedr√§ngt!"
- ‚úÖ Board hat 6 weniger dunkle Felder (visuell gepr√ºft)
- ‚úÖ LIFO funktioniert: √Ñu√üerster Ring entfernt (nicht Zentrum)

### Console-Logging

```javascript
// Bei darknessReduction > 0 UND dunkle Felder vorhanden:
üåü FEUER-Element aktiviert: 3 Finsternis-Felder zur√ºckgedr√§ngt! (8 ‚Üí 5)

// Bei darknessReduction > 0 ABER keine Finsternis vorhanden:
üåü WASSER-Element aktiviert: Keine Finsternis vorhanden zum Zur√ºckdr√§ngen

// Bei darknessReduction === 0:
(Kein Log - Feature nicht aktiv f√ºr dieses Element)
```

### Edge Cases

**Fall 1: Mehr Reduktion als Finsternis**
```javascript
// darknessReduction: 5, aber nur 2 dunkle Felder
fieldsToRemove = Math.min(5, 2);  // ‚Üí 2
// Resultat: Alle 2 Felder entfernt, keine Fehler
```

**Fall 2: Keine Finsternis vorhanden**
```javascript
if (darknessReduction > 0 && darkTiles.length > 0) {
  // Code wird NICHT ausgef√ºhrt
}
// Modal zeigt NICHT die darknessReduction Sektion
```

**Fall 3: Phase 1 (kein Herz der Finsternis)**
```javascript
// herzDerFinsternis.triggered === false
// darkTiles Array existiert nicht ‚Üí Feature inaktiv
```

### Best Practices

1. ‚úÖ **Ausgewogene Werte:** `darknessReduction` sollte < `darknessSpreadPerTurn √ó 3` sein
2. ‚úÖ **Element-Thematik:** Feuer/Wasser h√∂here Werte, Erde/Luft moderate Werte
3. ‚úÖ **Difficulty Scaling:** Schwerer Modus = niedrigere darknessReduction
4. ‚úÖ **Testing:** Immer mit verschiedenen darkTiles.length testen (0, 1, 5, 10+)

---

## üîß Testing-Workflow f√ºr Config-√Ñnderungen

### Schritt 1: Config-Datei bearbeiten
```bash
# Beispiel: events.json
vim src/config/events.json
```

### Schritt 2: Dev-Server erkennt √Ñnderung automatisch
```bash
# npm run dev l√§uft bereits
# Vite HMR (Hot Module Replacement) erkennt √Ñnderung
# Browser refresht automatisch
```

**‚úÖ Automatisch:** Bei `npm run dev` werden Config-√Ñnderungen automatisch erkannt.

### Schritt 3: Neues Spiel starten
```
1. Browser √∂ffnen (localhost:5173)
2. "Neues Spiel starten" klicken
3. Spieler-Setup durchf√ºhren
4. Spiel beginnt mit neuen Config-Werten
```

### Schritt 4: Testing
```
- Event triggern (Runde abschlie√üen bis Event erscheint)
- Werte validieren (Console-Logs pr√ºfen)
- UI-Feedback checken (Resolved-Texte, Icons)
```

---

## üí° Beispiel: "schwere_buerde" Value-√Ñnderung

### Ausgangssituation
```json
// src/config/events.json (ALT)
{
  "id": "schwere_buerde",
  "effects": [
    {
      "type": "reduce_ap",
      "value": 1,  // ‚Üê √ÑNDERN zu 2
      "target": "furthest_from_crater",
      "duration": "next_round"
    }
  ]
}
```

### √Ñnderung durchf√ºhren
```json
// src/config/events.json (NEU)
{
  "id": "schwere_buerde",
  "effects": [
    {
      "type": "reduce_ap",
      "value": 2,  // ‚Üê GE√ÑNDERT!
      "target": "furthest_from_crater",
      "duration": "next_round"
    }
  ]
}
```

### Code-Auswirkung

#### 1. Event-Effekt Anwendung
```javascript
// ApeironGame.jsx:2071 - VORHER
const newAp = Math.max(0, player.ap - 1);  // effect.value = 1

// ApeironGame.jsx:2071 - NACHHER
const newAp = Math.max(0, player.ap - 2);  // effect.value = 2
```

#### 2. Console-Log
```javascript
// VORHER
‚ö° reduce_ap ONE-TIME: Terra AP reduced to 2 (no persistent effect)

// NACHHER
‚ö° reduce_ap ONE-TIME: Terra AP reduced to 1 (no persistent effect)
```

#### 3. Resolved-Text
```javascript
// VORHER
Schwere B√ºrde: Terra (am weitesten vom Krater entfernt) haben in der n√§chsten Runde -1 AP.

// NACHHER
Schwere B√ºrde: Terra (am weitesten vom Krater entfernt) haben in der n√§chsten Runde -2 AP.
```

### Testing-Schritte

1. **Config √§ndern:** `value: 1` ‚Üí `value: 2` in events.json
2. **Browser refresht** automatisch (HMR)
3. **Neues Spiel starten** (Setup durchf√ºhren)
4. **Event triggern:**
   - Held vom Krater wegbewegen (z.B. Terra zu Position 8,8)
   - Runde abschlie√üen bis "Schwere B√ºrde" Event erscheint
5. **Validieren:**
   - ‚úÖ Console-Log zeigt `-2 AP`
   - ‚úÖ Resolved-Text zeigt `-2 AP`
   - ‚úÖ Held hat tats√§chlich 2 AP weniger (3 ‚Üí 1 statt 3 ‚Üí 2)

**‚ö†Ô∏è Bestehendes Spiel:** Laufendes Spiel hat Event-Deck bereits erstellt ‚Üí **Nicht betroffen!**

---

## üéØ Best Practices

### Config-√Ñnderungen testen
1. ‚úÖ **Immer neues Spiel starten** nach Config-√Ñnderung
2. ‚úÖ **Console-Logs pr√ºfen** f√ºr Effekt-Anwendung
3. ‚úÖ **Resolved-Texte validieren** im Event-Modal
4. ‚úÖ **Gameplay-Impact testen** (AP-Werte, Light-Counter, etc.)

### Mehrere √Ñnderungen gleichzeitig
```bash
# Batch-√Ñnderungen in einem Go
1. events.json: 3 Events anpassen
2. gameRules.json: Light-Werte √§ndern
3. tiles.json: Phase 2 Deck erweitern
4. Browser-Refresh
5. Neues Spiel starten ‚Üí Alle √Ñnderungen aktiv
```

### Production Deployment
```bash
npm run build       # Erstellt optimiertes Build mit neuen Configs
npm run preview     # Lokales Testing des Production-Builds
# Deploy to Server ‚Üí Neue Configs live
```

---

## üîç Debugging-Tipps

### Event-Deck inspizieren
```javascript
// In Browser Console
console.log(gameState.eventDeck);
// Zeigt alle Events im aktuellen Deck
```

### Tile-Deck inspizieren
```javascript
// In Browser Console
console.log(gameState.tileDeck);
console.log('Tiles remaining:', gameState.tileDeck.length);
```

### Game Rules zur Runtime pr√ºfen
```javascript
// In Browser Console
console.log(gameRules.light.startValue);      // 30
console.log(gameRules.actionPoints.perTurn);  // 3
console.log(gameRules.elementActivation.bonuses);
```

---

## üÜï Neues Event hinzuf√ºgen

### √úbersicht aller 20 implementierten Effekt-Typen

Das Event-System unterst√ºtzt **20 verschiedene Effekt-Typen**, die vollautomatisch funktionieren wenn sie in `events.json` verwendet werden:

#### Phase 1 Effekte (18 Typen)

| Effekt-Typ | Beschreibung | Unterst√ºtzte Targets | Ben√∂tigt duration? |
|------------|--------------|---------------------|-------------------|
| `light_gain` | Erh√∂ht Licht | - | ‚ùå Nein (instant) |
| `light_loss` | Reduziert Licht | - | ‚ùå Nein (instant) |
| `bonus_ap` | AP erh√∂hen | `all_players`, `random_hero` | ‚úÖ Ja (`next_round` / `permanent`) |
| `reduce_ap` | AP reduzieren | `all_players`, `random_hero`, `furthest_from_crater` | ‚úÖ Ja (`next_round` / `permanent`) |
| `set_ap` | AP auf festen Wert setzen | `all_players` | ‚úÖ Ja (`next_round` / `permanent`) |
| `add_resource` | Ressourcen hinzuf√ºgen | `active_player`, `crater`, `all_adjacent_to_crater` | ‚ùå Nein (instant) |
| `drop_resource` | Ressourcen ablegen | `hero_with_most_crystals`, `heroes_on_crater` | ‚ùå Nein (instant) |
| `drop_all_items` | Alle Items ablegen | `random_hero` | ‚ùå Nein (instant) |
| `drop_all_resources` | Alle Ressourcen eines Typs ablegen | `all_players` | ‚ùå Nein (instant) |
| `add_obstacle` | Hindernis platzieren | 8+ verschiedene Targets (siehe unten) | ‚ùå Nein (instant) |
| `skip_turn` | Spieler muss aussetzen | `random_hero` | ‚úÖ Ja (`next_round` / `permanent`) |
| `block_action` | Aktion blockieren | `all_players`, `random_hero` | ‚úÖ Ja (`next_round` / `permanent`) |
| `block_skills` | F√§higkeiten blockieren | `all_players`, `random_hero` | ‚úÖ Ja (`next_round` / `permanent`) |
| `prevent_movement` | Bewegung blockieren | `all_players`, `random_hero` | ‚úÖ Ja (`next_round` / `permanent`) |
| `disable_communication` | Kommunikation blockieren | `all_players` | ‚úÖ Ja (`next_round` / `permanent`) |
| `remove_obstacles` | Hindernisse entfernen (spezifischer Typ) | - | ‚ùå Nein (instant) |
| `remove_all_obstacles` | Alle Hindernisse entfernen | - | ‚ùå Nein (instant) |
| `remove_all_negative_effects` | Negative Effekte aufheben | `all_players` | ‚ùå Nein (instant) |

#### Phase 2 Effekte (2 Typen)

| Effekt-Typ | Beschreibung | Parameter | Ben√∂tigt duration? |
|------------|--------------|-----------|-------------------|
| `spread_darkness` | Finsternis ausbreiten | `value` (Anzahl Felder) | ‚ùå Nein (instant) |
| `cleanse_darkness` | Finsternis entfernen | `value` (Anzahl Felder) | ‚ùå Nein (instant) |

### Obstacle Placement Targets

F√ºr `add_obstacle` Effekt-Typ:
- `random_direction_from_crater` - Zuf√§llige Richtung vom Krater (N/E/S/W) via Card-Draw
- `north_of_crater`, `east_of_crater`, `south_of_crater`, `west_of_crater` - Spezifische Richtung
- `all_adjacent_to_crater` - Alle 4 angrenzenden Felder
- `diagonal_to_crater` - Alle 4 diagonalen Felder
- `ring_around_crater` - Ring mit 2 Feldern Distanz (16 Felder)
- `gate_and_adjacent` - Tor der Weisheit + angrenzende Felder
- `all_apeiron_sources_random_direction` - Alle Kristallquellen in gezogener Richtung
- `all_apeiron_sources_east` - Alle Kristallquellen im Osten
- `random_revealed_tile` - Zuf√§lliges aufgedecktes Feld

---

## üìú Duration-Werte Referenz

### ‚úÖ Unterst√ºtzte Duration-Werte

| Duration-Wert | Bedeutung | Verwendung | expiresInRound | Entfernbar? |
|---------------|-----------|------------|----------------|-------------|
| **`"next_round"`** | Wirkt in n√§chster Runde | AP-Effekte: Sofortige Anwendung<br>Status-Effekte: Dauerhafter Effekt | `currentRound + 1` | ‚úÖ Automatisch |
| **`"permanent"`** | Bleibt bis Spielende | Dauerhafter Effekt | `999999` | ‚úÖ Via Lyra's Reinigung |
| *Kein duration* | Sofortige Anwendung | Instant Effects (Light, Resources, Obstacles) | - | ‚ùå Nicht persistent |

### üéØ Wann welche Duration verwenden?

**`"next_round"` verwenden f√ºr:**
- Tempor√§re AP-Boni/Mali (1 Runde wirksam)
- Kurzzeitige Blockierungen (Entdecken, Sp√§hen)
- Einmalige Aussetzeffekte

**`"permanent"` verwenden f√ºr:**
- Langanhaltende Fl√ºche (z.B. dauerhafte AP-Reduktion)
- Permanente Blockierungen (z.B. Spieler kann sich nie mehr bewegen)
- Boss-F√§higkeiten in Phase 2

**Kein duration verwenden f√ºr:**
- Sofortige Licht-√Ñnderungen
- Ressourcen hinzuf√ºgen/entfernen
- Hindernisse platzieren/entfernen
- Finsternis-Operationen

---

## üîß Schritt-f√ºr-Schritt: Neues Event erstellen

### 1. Event in events.json hinzuf√ºgen

```json
{
  "id": "ewige_schw_che",
  "name": "Ewige Schw√§che",
  "symbol": "üíÄ",
  "type": "negative",
  "effectText": "Ein zuf√§lliger Held verliert permanent 1 AP pro Runde.",
  "description": "Eine dunkle Macht raubt einem Helden dauerhaft die Kraft.",
  "effects": [
    {
      "type": "reduce_ap",
      "value": 1,
      "target": "random_hero",
      "duration": "permanent"  // ‚Üê Permanenter Effekt!
    }
  ]
}
```

### 2. Mehrere Effekte kombinieren

Events k√∂nnen **mehrere Effekte** gleichzeitig haben:

```json
{
  "id": "katastrophale_wende",
  "name": "Katastrophale Wende",
  "symbol": "üí•",
  "type": "negative",
  "effectText": "Das Licht sinkt um 3, alle Helden haben permanent -1 AP, und die Finsternis breitet sich aus.",
  "description": "Ein verheerender Schlag gegen die Hoffnung.",
  "effects": [
    {
      "type": "light_loss",
      "value": 3
    },
    {
      "type": "reduce_ap",
      "value": 1,
      "target": "all_players",
      "duration": "permanent"
    },
    {
      "type": "spread_darkness",
      "value": 2
    }
  ]
}
```

### 3. Card-Draw Events (mit Richtungskarten)

Manche Effekte erfordern dass der Spieler eine Karte zieht:

```json
{
  "id": "finstere_blockade",
  "name": "Finstere Blockade",
  "symbol": "ü™®",
  "type": "negative",
  "effectText": "Platziere ein permanentes Hindernis in einer zuf√§lligen Richtung vom Krater.",
  "description": "**Ziehe jetzt eine Himmelsrichtungskarte, um die betroffene Richtung zu bestimmen!**",
  "effects": [
    {
      "type": "add_obstacle",
      "obstacle": "geroell",
      "target": "random_direction_from_crater"  // ‚Üê Triggert Card-Draw
    }
  ]
}
```

---

## ‚úÖ Was automatisch funktioniert

Wenn du ein neues Event mit **bekannten Effekt-Typen** hinzuf√ºgst:

1. ‚úÖ **Event-Deck Loading** - Event wird beim Spielstart ins Deck geladen
2. ‚úÖ **Event-Triggering** - Event wird am Rundenende zuf√§llig gezogen
3. ‚úÖ **Effekt-Anwendung** - Alle Effekte werden korrekt angewendet
4. ‚úÖ **Console-Logs** - Debug-Ausgaben zeigen Effekt-Anwendung
5. ‚úÖ **Visual Indicators** - Effekt-Icons erscheinen automatisch auf Helden-Tafel
6. ‚úÖ **Permanente Effekte** - ‚ôæÔ∏è Symbol wird angezeigt bei `"duration": "permanent"`
7. ‚úÖ **Resolved-Texte** - Event-Beschreibungen werden im Modal angezeigt

---

## ‚ö†Ô∏è Was manuelle Anpassung braucht

### ‚ùå Fall 1: Neuer Effekt-Typ

```json
{
  "effects": [
    {
      "type": "teleport_hero",  // ‚Üê UNBEKANNTER TYP!
      "target": "random_hero"
    }
  ]
}
```

**Problem:** Switch-case in `applyEventEffect()` kennt `teleport_hero` nicht
**L√∂sung:** Code-√Ñnderung erforderlich - neuen `case` hinzuf√ºgen (Line ~1956)

### ‚ùå Fall 2: Neues Target

```json
{
  "effects": [
    {
      "type": "bonus_ap",
      "target": "hero_with_least_ap"  // ‚Üê UNBEKANNTES TARGET!
    }
  ]
}
```

**Problem:** `bonus_ap` kennt nur `all_players` und `random_hero`
**L√∂sung:** Code-√Ñnderung erforderlich - Target-Logik erweitern

### ‚ö†Ô∏è Fall 3: Custom Resolved-Texte

```json
{
  "id": "mein_neues_event",
  "effects": [...]
}
```

**Problem:** Resolved-Text ist teilweise hardcoded (23 Stellen)
**Beispiel:** `resolvedTexts.push("Schwere B√ºrde: ...")` (Line 2082)
**Workaround:** Generic-Text wird verwendet - funktioniert aber nicht perfekt

---

## üî¨ Permanente Effekte entfernen

### Via Event: `remove_all_negative_effects`

```json
{
  "id": "apeirons_segen",
  "effects": [
    {
      "type": "remove_all_negative_effects",
      "target": "all_players"
    }
  ]
}
```

Entfernt **ALLE** negativen Effekte inkl. permanente:
- `skip_turn`
- `reduce_ap`
- `set_ap`
- `prevent_movement`
- `block_skills`
- Action Blockers

### Via Lyra's F√§higkeit: "Heilende Reinigung"

**Automatisch:** Lyra's "Heilende Reinigung" Skill kann:
1. ‚úÖ Finsternis von Feldern entfernen (Phase 2)
2. ‚úÖ Negative Effekte von Spielern entfernen (via `remove_all_negative_effects` Event)

**Hinweis:** Aktuell gibt es keinen separaten Skill-Button um Player-Effekte zu entfernen - nur via Events.

---

## üí° Praktische Beispiele

### Beispiel 1: Permanente AP-Erh√∂hung

```json
{
  "id": "segen_der_urkraft",
  "name": "Segen der Urkraft",
  "symbol": "‚ú®",
  "type": "positive",
  "effectText": "Alle Helden erhalten permanent +1 AP pro Runde.",
  "description": "Die Ursubstanz st√§rkt euch dauerhaft.",
  "effects": [
    {
      "type": "bonus_ap",
      "value": 1,
      "target": "all_players",
      "duration": "permanent"
    }
  ]
}
```

**Resultat:**
- Alle Spieler haben ab sofort 4 AP statt 3 AP pro Runde
- Effekt bleibt bis Spielende (expiresInRound: 999999)
- ‚ôæÔ∏è Symbol erscheint neben ‚ö° Icon auf Helden-Tafel
- Kann via "Apeirons Segen" Event entfernt werden

### Beispiel 2: Permanente Bewegungsblockierung

```json
{
  "id": "versteinerung",
  "name": "Versteinerung",
  "symbol": "üóø",
  "type": "negative",
  "effectText": "Ein zuf√§lliger Held kann sich permanent nicht mehr bewegen.",
  "description": "Dunkle Magie versteinert einen Helden f√ºr immer.",
  "effects": [
    {
      "type": "prevent_movement",
      "target": "random_hero",
      "duration": "permanent"
    }
  ]
}
```

**Resultat:**
- Random Held kann sich NIE mehr bewegen
- Andere Aktionen (Sammeln, Skills, Bauen) noch m√∂glich
- ‚õìÔ∏è‚ôæÔ∏è Symbole erscheinen auf Helden-Tafel
- Nur via "Apeirons Segen" oder Lyra entfernbar

### Beispiel 3: Multi-Effekt Permanent Event (Phase 2 Boss)

```json
{
  "id": "zorn_der_sphaere_erwacht",
  "name": "Zorn der Sph√§re erwacht",
  "symbol": "üëÅÔ∏è",
  "type": "negative",
  "effectText": "Das Licht sinkt um 5, alle Helden haben permanent -2 AP, und die Finsternis breitet sich auf 3 Felder aus.",
  "description": "Die Sph√§re entfesselt ihre volle Macht in einem verzweifelten Akt.",
  "effects": [
    {
      "type": "light_loss",
      "value": 5
    },
    {
      "type": "reduce_ap",
      "value": 2,
      "target": "all_players",
      "duration": "permanent"
    },
    {
      "type": "spread_darkness",
      "value": 3
    },
    {
      "type": "block_skills",
      "target": "random_hero",
      "duration": "permanent"
    }
  ]
}
```

**Resultat:**
- 4 verschiedene Effekte gleichzeitig
- 2 permanente Effekte (AP + Skills) + 2 instant Effekte (Light + Darkness)
- Dramatischer Boss-Moment in Phase 2
- Spieler m√ºssen "Apeirons Segen" Event ziehen um zu √ºberleben

### Beispiel 4: Element-Aktivierung Balance-Anpassung (darknessReduction)

**Szenario:** Feuer-Element soll st√§rker gegen Finsternis wirken

```json
// gameRules.json - VORHER (Standard)
{
  "elementActivation": {
    "bonuses": {
      "feuer": {
        "type": "light",
        "value": 4,
        "darknessReduction": 4
      }
    }
  }
}

// gameRules.json - NACHHER (Buff)
{
  "elementActivation": {
    "bonuses": {
      "feuer": {
        "type": "light",
        "value": 4,
        "darknessReduction": 7  // ‚Üê ERH√ñHT von 4 auf 7
      }
    }
  }
}
```

**Impact:**
- Feuer-Element aktivieren entfernt jetzt 7 Finsternis-Felder (statt 4)
- Strategische Entscheidung: Feuer priorisieren in Phase 2
- Balance: `darknessSpreadPerTurn: 2` ‚Üí Netto-Gewinn: 7 - 2 = 5 Felder pro Aktivierung

**Testing:**
```javascript
// Vor √Ñnderung (darknessReduction: 4):
üåü FEUER-Element aktiviert: 4 Finsternis-Felder zur√ºckgedr√§ngt! (10 ‚Üí 6)

// Nach √Ñnderung (darknessReduction: 7):
üåü FEUER-Element aktiviert: 7 Finsternis-Felder zur√ºckgedr√§ngt! (10 ‚Üí 3)
```

### Beispiel 5: Schwierigkeitsgrad-Anpassung (alle 4 Elemente)

**Szenario:** Leichteren Modus erstellen durch h√∂here darknessReduction

```json
// gameRules.json - Leichter Modus
{
  "elementActivation": {
    "bonuses": {
      "wasser": {
        "type": "light",
        "value": 5,              // +1 Light (statt 4)
        "darknessReduction": 6   // +2 Felder (statt 4)
      },
      "feuer": {
        "type": "light",
        "value": 5,
        "darknessReduction": 8   // +4 Felder (statt 4) - ST√ÑRKSTER EFFEKT
      },
      "luft": {
        "type": "permanent_ap",
        "value": 1,
        "darknessReduction": 5   // +1 Feld (statt 4)
      },
      "erde": {
        "type": "permanent_ap",
        "value": 1,
        "darknessReduction": 4   // UNVER√ÑNDERT
      }
    }
  },
  "phase2": {
    "darknessSpreadPerTurn": 2  // Gleichbleibend
  }
}
```

**Resultat:**
- Durchschnittliche darknessReduction: 5.75 Felder (statt 4)
- Netto-Effekt pro Aktivierung: +3.75 Felder (statt +2)
- Strategische Vielfalt: Feuer am st√§rksten, Erde am schw√§chsten
- Spieler k√∂nnen mit 4 Element-Aktivierungen ~23 Finsternis-Felder entfernen

**Gameplay-Impact:**
- Phase 2 deutlich einfacher ‚Üí Mehr Raum f√ºr Fehler
- Finsternis-Bedrohung weniger kritisch
- Empfohlen f√ºr: Anf√§nger, Story-Fokus, Casual-Spieler

---

## üéØ Testing-Checklist

Nach Hinzuf√ºgen eines neuen Events:

1. ‚úÖ **JSON-Syntax validieren** - `npm run lint` (falls ESLint JSON pr√ºft)
2. ‚úÖ **Browser Refresh** - Dev-Server erkennt √Ñnderung automatisch
3. ‚úÖ **Neues Spiel starten** - Event Deck wird neu erstellt
4. ‚úÖ **Event triggern** - Runde abschlie√üen bis Event erscheint
5. ‚úÖ **Console-Logs pr√ºfen** - Debug-Ausgaben validieren
6. ‚úÖ **Effekt-Werte testen** - AP, Light, Ressourcen pr√ºfen
7. ‚úÖ **Visual Indicators checken** - Icons auf Helden-Tafel
8. ‚úÖ **Permanente Effekte** - ‚ôæÔ∏è Symbol sichtbar?
9. ‚úÖ **Mehrere Runden testen** - Permanente Effekte bleiben aktiv?
10. ‚úÖ **Entfernung testen** - "Apeirons Segen" entfernt Effekte?

---

## üìä Statistiken

**Aktueller Stand (2025-10-06):**
- 58 implementierte Event-Karten (Phase 1 + Phase 2)
- 20 verschiedene Effekt-Typen vollautomatisch
- 15+ verschiedene Target-Varianten
- 3 Duration-Werte (`next_round`, `permanent`, instant)
- ‚ôæÔ∏è Visual Indicators f√ºr permanente Effekte
- üÜï **Element-Aktivierung Bonusse:** 4 Elemente mit individuellen darknessReduction Werten
- üÜï **Finsternis-Zur√ºckdr√§ngung:** LIFO-Prinzip f√ºr strategische Gameplay-Balance
- üÜï **Multi-Obstacles System:** Mehrere verschiedene Obstacle-Typen pro Feld m√∂glich

**Config-Dateien:**
- `events.json`: ~1500 Zeilen, 58 Events
- `gameRules.json`: 60 Zeilen, 6 Haupt-Kategorien (light, actionPoints, inventory, foundations, elementActivation, phase2)
- `tiles.json`: ~300 Zeilen, 24 Phase 1 + 24 Phase 2 Karten

**Features dokumentiert:**
- ‚úÖ Event-System (20 Effekt-Typen)
- ‚úÖ Game Rules (Runtime-Checks + Initial-Values)
- ‚úÖ Tile-Deck System (Phase 1 + Phase 2)
- ‚úÖ Phase 2 Configuration (darknessSpreadPerTurn)
- ‚úÖ Element-Aktivierung Bonusse (darknessReduction) üÜï

---

## üìö Weitere Ressourcen

- [spielanleitung.md](./spielanleitung.md) - Vollst√§ndige Spielregeln
- [ereigniskarten.md](./ereigniskarten.md) - Alle 58 Event-Karten mit Effekten
- [events.json](../src/config/events.json) - Event-Definitionen
- [gameRules.json](../src/config/gameRules.json) - Balance-Parameter
- [tiles.json](../src/config/tiles.json) - Landschaftskarten-Definitionen

---

*Zuletzt aktualisiert: 2025-10-06 - Finsternis-Zur√ºckdr√§ngung Feature (darknessReduction)*
